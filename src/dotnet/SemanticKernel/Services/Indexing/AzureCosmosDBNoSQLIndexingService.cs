using Azure.ResourceManager;
using FoundationaLLM.Common.Exceptions;
using FoundationaLLM.Common.Interfaces;
using FoundationaLLM.Common.Models.Configuration.CosmosDB;
using FoundationaLLM.Common.Models.Vectorization;
using FoundationaLLM.SemanticKernel.Core.Models.Configuration;
using Microsoft.Azure.Cosmos;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.SemanticKernel.Connectors.AzureCosmosDBNoSQL;
using Microsoft.SemanticKernel.Memory;
using System.Collections.ObjectModel;
using System.Text.Json;
using Embedding = Microsoft.Azure.Cosmos.Embedding;

#pragma warning disable SKEXP0001, SKEXP0020

namespace FoundationaLLM.SemanticKernel.Core.Services.Indexing
{
    /// <summary>
    /// Provides vector embedding indexing based on the Azure Cosmos DB NoSQL API.
    /// </summary>
    public class AzureCosmosDBNoSQLIndexingService : IIndexingService
    {
        private readonly AzureCosmosDBNoSQLIndexingServiceSettings _settings;
        private readonly ILogger<AzureCosmosDBNoSQLIndexingService> _logger;
        private readonly AzureCosmosDBNoSQLMemoryStore _memoryStore;

        /// <summary>
        /// Creates a new <see cref="AzureCosmosDBNoSQLIndexingService"/> instance.
        /// </summary>
        /// <param name="options">The <see cref="IOptions{TOptions}"/> providing configuration settings.</param>
        /// <param name="logger">The <see cref="ILogger"/> used for logging.</param>
        public AzureCosmosDBNoSQLIndexingService(
            IOptions<AzureCosmosDBNoSQLIndexingServiceSettings> options,
            ILogger<AzureCosmosDBNoSQLIndexingService> logger)
        {
            _settings = options.Value;
            _logger = logger;
            _memoryStore = CreateMemoryStore();
        }

        /// <inheritdoc/>
        public async Task<List<string>> IndexEmbeddingsAsync(EmbeddedContent embeddedContent, string indexName)
        {
            if (!await _memoryStore.DoesCollectionExistAsync(indexName, default).ConfigureAwait(false))
            {
                await _memoryStore.CreateCollectionAsync(indexName, default).ConfigureAwait(false);
            }

            var indexIds = new List<string>();
            var memoryRecords = embeddedContent.ContentParts.Select(cp => MemoryRecord.LocalRecord(
                cp.Id,
                cp.Content,
                "Generated by FoundationaLLM.",
                cp.Embedding.Vector,
                JsonSerializer.Serialize(embeddedContent.ContentId),
                embeddedContent.ContentId.UniqueId,
                DateTimeOffset.UtcNow)).ToList();

            await foreach (var id in _memoryStore.UpsertBatchAsync(
                indexName, memoryRecords))
            {
                indexIds.Add(id);
            }

            return indexIds;
        }

        private void ValidateSettings(string connectionString, string? databaseName)
        {
            if (string.IsNullOrWhiteSpace(connectionString))
            {
                _logger.LogCritical("The Azure Cosmos DB connection string is invalid.");
                throw new ConfigurationValueException("The Azure Cosmos DB connection string is invalid.");
            }

            if (string.IsNullOrWhiteSpace(databaseName))
            {
                _logger.LogCritical("The Azure Cosmos DB vector database name is invalid.");
                throw new ConfigurationValueException("The Azure Cosmos DB vector database name is invalid.");
            }
        }

        /// <summary>
        /// Creates an <see cref="AzureCosmosDBNoSQLMemoryStore"/> instance using the injected
        /// <see cref="CosmosClient"/> and <see cref="CosmosDbSettings"/>.
        /// </summary>
        /// <returns></returns>
        private AzureCosmosDBNoSQLMemoryStore CreateMemoryStore()
        {
            ValidateSettings(_settings.ConnectionString, _settings.VectorDatabase);
            return new AzureCosmosDBNoSQLMemoryStore(
                _settings.ConnectionString,
                _settings.VectorDatabase!,
                new VectorEmbeddingPolicy(
                    new Collection<Embedding>(
                    [
                        new Embedding()
                        {
                            Path = "/embedding",
                            DataType = VectorDataType.Float32,
                            DistanceFunction = DistanceFunction.Cosine,
                            Dimensions = 3072
                        }
                    ])),
                new IndexingPolicy()
                {
                    VectorIndexes =
                    [
                        new VectorIndexPath()
                        {
                            Path = "/embedding",
                            Type = VectorIndexType.QuantizedFlat
                        }
                    ]
                }
            );
        }
    }
}
